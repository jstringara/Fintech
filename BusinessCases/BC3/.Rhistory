legend("topleft",legend = colnames(azioni),col=c('blue','green','cyan','red'),
lty=1,lwd=3,cex=1.4)
matplot
open(ssss)
library(readr)
dataset <- read_table2(NULL, col_names = FALSE)
miii <- read.csv2("C:/Users/giuli/Downloads/miii.csv", encoding="UTF-8", header=FALSE, sep="")
View(miii)
miii[135,1]=995728
miii[135,2]=11.4
miii=miii[!136,]
miii <- read.csv2("C:/Users/giuli/Downloads/miii.csv", encoding="UTF-8", header=FALSE, sep="")
View(miii)
miii[135,1]=995728
miii[135,2]=11.4
miii=miii[-miii[136,],]
miii=rbind(miii[1:135,],miii[137:,])
miii=rbind(miii[1:135,],miii[137:154,])
attach(miii)
mean(V2)
median(V2)
min(V2)
max(V2)
hist(V2)
boxplot(v2)
boxplot(V2)
quantiles(V2)
quantile(V2)
help("hist")
hist(V2,breaks=c(0:1:33))
v=1:3
names(v)=c("a","b","c")
v[4]=4
v[4]
install.packages("devtools")
require(devtools)
install_version("fdakma", version = "1.2.1", repos = "http://cran.r-project.org")
km          <- c(18.7, 16.8, 20.1, 22.4, 14.0, 15.2, 22.0, 23.3)
distr       <- factor(c('Esso','Esso','Esso','Esso','Shell','Shell','Shell','Shell'))
benz        <- factor(c('95','95','98','98','95','95','98','98'))
distr_benz  <- factor(c('Esso95','Esso95','Esso98','Esso98','Shell95','Shell95','Shell98','Shell98'))
g <- length(levels(distr))
b <- length(levels(benz))
n <- length(km)/(g*b)
M           <- mean(km)
Mdistr      <- tapply(km,      distr, mean)
Mbenz       <- tapply(km,       benz, mean)
Mdistr_benz <- tapply(km, distr_benz, mean)
par(mfrow=c(2,3),las=2)
barplot(rep(M,4), names.arg=levels(distr_benz), ylim=c(0,24), main='No factor')
barplot(rep(Mdistr,each=2), names.arg=levels(distr_benz), ylim=c(0,24),
col=rep(c('blue','red'),each=2), main='Only Fact. Stat.')
barplot(rep(Mbenz,times=2), names.arg=levels(distr_benz), ylim=c(0,24),
col=rep(c('darkgreen','orange'),times=2), main='Only Fact. Gas')
barplot(c(Mdistr[1]+Mbenz[1]-M, Mdistr[1]+Mbenz[2]-M, Mdistr[2]+Mbenz[1]-M,
Mdistr[2]+Mbenz[2]-M), names.arg=levels(distr_benz), ylim=c(0,24),
col=rep(c('darkgreen','orange'),times=2), density=rep(10,4), angle=135,
main='Additive model Stat.+Gas')
barplot(c(Mdistr[1]+Mbenz[1]-M, Mdistr[1]+Mbenz[2]-M, Mdistr[2]+Mbenz[1]-M,
Mdistr[2]+Mbenz[2]-M), names.arg=levels(distr_benz), ylim=c(0,24),
col=rep(c('blue','red'),each=2), density=rep(10,4), add=T)
barplot(Mdistr_benz, names.arg=levels(distr_benz), ylim=c(0,24),
col=rainbow(5)[2:5], main='Model with Interact. Stat.+Gas.')
plot(distr_benz, km, col=rainbow(5)[2:5], ylim=c(0,24),xlab='')
fit.aov2.int <- aov(km ~ distr + benz + distr:benz)
summary.aov(fit.aov2.int)
View(miii)
library(MASS)
library(car)
library(rgl)
library(glmnet)
# Variance inflation factor
vif(fm)
### A possible solution to collinearity: PCA
speed.pc <- princomp(cbind(speed1,speed2), scores=TRUE)
summary(speed.pc)
speed.pc$load
sp1.pc <- speed.pc$scores[,1]
sp2.pc <- speed.pc$scores[,2]
# Now we estimate the model by inserting the PCs instead of the
# original regressors
# Model: y = b0 + b1*PC1+ b2*PC2 + eps, eps~N(0,sigma^2)
fm.pc <- lm(distance ~ sp1.pc + sp2.pc)
summary(fm.pc)
### Another possible solution: RIDGE
# Fix lambda
lambda <- .5
lambda.c <- seq(0,10,0.01) #Â for cross-validation
fit.ridge <- lm.ridge(distance ~ speed1 + speed2, lambda = lambda)
# Note: to fit the model, R automatically centers X and Y
# with respect to their mean.
coef.ridge <- coef(fit.ridge)
yhat.lm <- cbind(rep(1,n), speed1, speed2)%*%coef(fm)  # LM fitted values
yhat.r <- cbind(rep(1,n), speed1, speed2)%*%coef.ridge # ridge fitted values
# Choice of the optimal lambda, e.g., via cross-validation
select(fit.ridge)
# or
lambda.opt <- lambda.c[which.min(fit.ridge$GCV)]
lambda.opt
### Another possible solution: LASSO
# Build the matrix of predictors
x <- model.matrix(distance~speed1+speed2, data=data)[,-1]
# Build the vector of response
y <- distance
# Let's set a grid of candidate lambda's for the estimate
lambda.grid <- seq(0.01,1,length=100)
lambda.grid <- 10^seq(5,-3,length=100)
fit.lasso <- glmnet(x,y, lambda = lambda.grid)
# alpha = 1 -> Lasso (default)
# alpha = 0 -> Ridge
plot(fit.lasso,xvar='lambda',label=TRUE, col = rainbow(dim(x)[2]))
legend('topright', dimnames(x)[[2]], col =  rainbow(dim(x)[2]), lty=1, cex=1)
# Let's set lambda via cross validation
cv.lasso <- cv.glmnet(x,y,lambda=lambda.grid) # default: 10-fold CV
bestlam.lasso <- cv.lasso$lambda.min
bestlam.lasso
plot(cv.lasso)
abline(v=log(bestlam.lasso), lty=1)
# Get the coefficients for the optimal lambda
coef.lasso <- predict(fit.lasso, s=bestlam.lasso, type = 'coefficients')[1:3,]
coef.lasso
q()
install.packages('haven')
library(haven)
data <- read_dta('"C:\Users\giuli\OneDrive\Desktop\Tesi\Dropbox Maestripieri\VulnYouth clean.dta"')
data <- read_dta("C:\Users\giuli\OneDrive\Desktop\Tesi\Dropbox Maestripieri\VulnYouth clean.dta")
data <- read_dta("C:/Users/giuli/OneDrive/Desktop/Tesi/Dropbox Maestripieri/VulnYouth clean.dta")
View(data)
table(is.na(data))
boxplot(scale(data))
setwd("C:/Users/giuli/OneDrive/Desktop/Fintech/Fintech/BC3")
setwd("C:/Users/giuli/OneDrive/Desktop/Fintech/Fintech/BC3")
library(mvtnorm)
tourists <- read.csv('EWS.csv', header=T)
View(tourists)
head(tourists)
tourists.label <- tourists[,1:2]
tourists <- tourists[,-(1:2)]
n <- dim(tourists)[1]
p <- dim(tourists)[2]
# Boxplot
x11()
par(mar=rep(8,4))
boxplot(tourists, las=2, col='gold')
x11()
par(mar=rep(8,4))
boxplot(scale(x=tourists,center = T, scale=F), las=2, col='gold')
x11()
par(mar=rep(8,4))
boxplot(scale(x=tourists,center = T, scale=T), las=2, col='gold')
# We perform the PCA on original data
pc.tourists <- princomp(tourists, scores=T)
pc.tourists
summary(pc.tourists)
# To obtain the rows of the summary:
# standard deviation of the components
pc.tourists$sd
# proportion of variance explained by each PC
pc.tourists$sd^2/sum(pc.tourists$sd^2)
# cumulative proportion of explained variance
cumsum(pc.tourists$sd^2)/sum(pc.tourists$sd^2)
load.tour <- pc.tourists$loadings
load.tour
load.tour[,1:3]
x11()
par(mfrow = c(3,1))
for(i in 1:3) barplot(load.tour[,i], ylim = c(-1, 1))
x11()
layout(matrix(c(2,3,1,3),2,byrow=T))
plot(pc.tourists, las=2, main='Principal components', ylim=c(0,4.5e7))
barplot(sapply(tourists,sd)^2, las=2, main='Original Variables', ylim=c(0,4.5e7), ylab='Variances')
plot(cumsum(pc.tourists$sd^2)/sum(pc.tourists$sd^2), type='b', axes=F, xlab='number of components',
ylab='contribution to the total variance', ylim=c(0,1))
abline(h=1, col='blue')
abline(h=0.8, lty=2, col='blue')
box()
axis(2,at=0:10/10,labels=0:10/10)
axis(1,at=1:ncol(tourists),labels=1:ncol(tourists),las=2)
pc.tourists
View(pc.tourists)
# We compute the standardized variables
tourists.sd <- scale(tourists)
tourists.sd <- data.frame(tourists.sd)
head(tourists.sd)
pc.tourists <- princomp(tourists.sd, scores=T)
pc.tourists
summary(pc.tourists)
# Explained variance
x11()
layout(matrix(c(2,3,1,3),2,byrow=T))
plot(pc.tourists, las=2, main='Principal Components', ylim=c(0,7))
abline(h=1, col='blue')
barplot(sapply(tourists.sd,sd)^2, las=2, main='Original Variables', ylim=c(0,7), ylab='Variances')
plot(cumsum(pc.tourists$sde^2)/sum(pc.tourists$sde^2), type='b', axes=F, xlab='Number of components', ylab='Contribution to the total variance', ylim=c(0,1))
box()
axis(2,at=0:10/10,labels=0:10/10)
axis(1,at=1:ncol(tourists.sd),labels=1:ncol(tourists.sd),las=2)
# loadings
load.tour <- pc.tourists$loadings
load.tour
x11()
par(mar = c(2,2,2,1), mfrow=c(3,1))
for(i in 1:3)barplot(load.tour[,i], ylim = c(-1, 1), main=paste('Loadings PC ',i,sep=''))
# scores
scores.tourists <- pc.tourists$scores
scores.tourists
x11()
plot(scores.tourists[,1:2])
abline(h=0, v=0, lty=2, col='grey')
x11()
plot(scores.tourists[,1:2])
abline(h=0, v=0, lty=2, col=tourists$Y)
View(tourists)
x11()
plot(scores.tourists[,1:2])
abline(h=0, v=0, lty=2, col=tourists.label$Y)
View(tourists.label)
abline(h=0, v=0, lty=2, col=tourists.label$Y+1)
x11()
plot(scores.tourists[,1:2])
abline(h=0, v=0, lty=2, col=tourists.label$Y+1)
x11()
plot(scores.tourists[,1:2], col=tourists.label$Y)
abline(h=0, v=0, lty=2)
x11()
plot(scores.tourists[,1:2], col=tourists.label$Y+1)
abline(h=0, v=0, lty=2)
plot3D(scores.tourists[,1:3])
plot3d(scores.tourists[,1:3])
library(plot3D)
plot3d(scores.tourists[,1:3])
plot3D(scores.tourists[,1:3])
library(plot3D)
plot3D(scores.tourists[,1:3])
library(rgl)
plot3D(scores.tourists[,1:3])
plot3d(scores.tourists[,1:3])
plot3d(scores.tourists[,1:3],col=tourists.label$Y+3)
plot3d(scores.tourists[,1:3],col=tourists.label$Y+2)
corrplot(tourists)
corr(tourists)
cor(tourists)
plot(cor(tourists))
cor(tourists)
heatmap(cor(tourists))
library(car)
library(mvtnorm)
dat <- read.csv('EWS.csv', header=T)
head(dat)
dat.label <- dat[,1:2]
dat <- dat[,-(1:2)]
heatmap(cor(dat))
n <- dim(dat)[1]
p <- dim(dat)[2]
################## BOX-COX #######################
## Univariate Box-Cox transformation
lambda.x <- powerTransform(dat)
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat)
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(col(dat))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(c(dat[,1:]))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(c(dat[,1:42]))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat[,1:42])
View(dat)
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat[,-c(3)])
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat[,-2])
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat$)
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat$names(col(dat)))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(names(col(dat)))
names(col(dat))
col(dat)
names(dat)
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(names(dat)))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(names(dat))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat$names(dat))
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat,family="bcnPower")
################## BOX-COX #######################
## Multivariate Box-Cox (p=2)
lambda <- powerTransform(dat,family="bcnPower")
hist(dat)
View(miii)
View(dat)
scatterplot(dat)
plot(dat)
x11()
plot(dat)
x11()
par(mfrow=c(6,7))
plot(dat)
x11()
par(mfrow=c(4,5))
plot(dat)
hist(dat$XAUBGNL)
for i in names(dat):
for(i in names(dat)):
for(i in names(dat))
hist(dat[,i])
for(i in names(dat))
lambda.x <- powerTransform(dat[,i])
for(i in names(dat))
lambda.x <- powerTransform(dat[,i],family="bcpower")
for(i in names(dat))
lambda.x <- powerTransform(dat[,i],family="bcnpower")
for(i in names(dat))
lambda.x <- powerTransform(dat[,i],family="bcnPower")
# lambda<1: observations <1 are "spread", observations >1 are "shrinked"
# Transformed sample with the optimal lambda (command bcPower of library car)
dat[,i] <- bcPower(dat[,i], lambda.x$lambda)      # it transforms the data of the first argument through the Box-Cox
# transformation with lambda given as second argument
View(dat)
hist(dat[,1])
for(i in 1:42)
lambda.x <- powerTransform(dat[,i],family="bcnPower")
# lambda<1: observations <1 are "spread", observations >1 are "shrinked"
# Transformed sample with the optimal lambda (command bcPower of library car)
dat[,i] <- bcPower(dat[,i], lambda.x$lambda)      # it transforms the data of the first argument through the Box-Cox
# transformation with lambda given as second argument
View(dat)
hist(dat[,1])
lambda.x <- powerTransform(dat[,1],family="bcnPower")
# lambda<1: observations <1 are "spread", observations >1 are "shrinked"
# Transformed sample with the optimal lambda (command bcPower of library car)
dat[,1] <- bcPower(dat[,1], lambda.x$lambda)
hist(dat[,1])
lambda.x <- powerTransform(dat[,1],family="bc")
lambda.x <- powerTransform(dat[,1],family="bcPower")
# lambda<1: observations <1 are "spread", observations >1 are "shrinked"
# Transformed sample with the optimal lambda (command bcPower of library car)
dat[,1] <- bcPower(dat[,1], lambda.x$lambda)
hist(dat[,1])
hist(dat[,2])
lambda.x <- powerTransform(dat[,2],family="bcPower")
